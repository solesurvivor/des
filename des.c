//DES code by Shaarad Dalvi
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

/*
Defining aliases for datatypes.
BYTE,WORD,DWORD(Double Word),QWORD(Quad Word) are 8-bit,16-bit and 32-bit unsigned integers respectively.
SBYTE is 8-bit signed integer used in loops, especilly when termination is required on reaching negative value.
*/
typedef uint8_t BYTE;
typedef int8_t SBYTE;
typedef uint16_t WORD;
typedef uint32_t DWORD;
typedef uint64_t QWORD;

/*
Initial permutation table of DES. Ordered as most significant bit to least significant bit.
*/
const BYTE init_perm[64]={	0x39,0x31,0x29,0x21,0x19,0x11,0x09,0x01,
							0x3b,0x33,0x2b,0x23,0x1b,0x13,0x0b,0x03,
							0x3d,0x35,0x2d,0x25,0x1d,0x15,0x0d,0x05,
							0x3f,0x37,0x2f,0x27,0x1f,0x17,0x0f,0x07,
							0x38,0x30,0x28,0x20,0x18,0x10,0x08,0x00,
							0x3a,0x32,0x2a,0x22,0x1a,0x12,0x0a,0x02,
							0x3c,0x34,0x2c,0x24,0x1c,0x14,0x0c,0x04,
							0x3e,0x36,0x2e,0x26,0x1e,0x16,0x0e,0x06
						};

/*
Final permutation table of DES. Ordered as most significant bit to least significant bit.
*/
const BYTE final_perm[64]={	0x27,0x07,0x2f,0x0f,0x37,0x17,0x3f,0x1f,
							0x26,0x06,0x2e,0x0e,0x36,0x16,0x3e,0x1e,
							0x25,0x05,0x2d,0x0d,0x35,0x15,0x3d,0x1d,
							0x24,0x04,0x2c,0x0c,0x34,0x14,0x3c,0x1c,
							0x23,0x03,0x2b,0x0b,0x33,0x13,0x3b,0x1b,
							0x22,0x02,0x2a,0x0a,0x32,0x12,0x3a,0x1a,
							0x21,0x01,0x29,0x09,0x31,0x11,0x39,0x19,
							0x20,0x00,0x28,0x08,0x30,0x10,0x38,0x18
						};

/*
Straight D-box used in the DES function. Ordered as most significant bit to least significant bit.
*/
const BYTE straight_d[32]={	0x0f,0x06,0x13,0x14,0x1c,0x0b,0x1b,0x10,
							0x00,0x0e,0x16,0x19,0x04,0x11,0x1e,0x09,
							0x01,0x07,0x17,0x0d,0x1f,0x1a,0x02,0x08,
							0x12,0x0c,0x1d,0x05,0x15,0x0a,0x03,0x18
						};

/*
Parity drop table for key generation. Ordered as most significant bit to least significant bit.
*/
const BYTE parity_drop[56]={	0x38,0x30,0x28,0x20,0x18,0x10,0x08,0x00,
								0x39,0x31,0x29,0x21,0x19,0x11,0x09,0x01,
								0x3a,0x32,0x2a,0x22,0x1a,0x12,0x0a,0x02,
								0x3b,0x33,0x2b,0x23,0x3e,0x36,0x2e,0x26,
								0x1e,0x16,0x0e,0x06,0x3d,0x35,0x2d,0x25,
								0x1d,0x15,0x0d,0x05,0x3c,0x34,0x2c,0x24,
								0x1c,0x14,0x0c,0x04,0x1b,0x13,0x0b,0x03
						};

/*
Compression D-box used in key generation. Ordered as most significant bit to least significant bit.
*/
const BYTE key_compression[48]={	0x0d,0x10,0x0a,0x17,0x00,0x04,0x02,0x1b,
									0x0e,0x05,0x14,0x09,0x16,0x12,0x0b,0x03,
									0x19,0x07,0x0f,0x06,0x1a,0x13,0x0c,0x01,
									0x28,0x33,0x1e,0x24,0x2e,0x36,0x1d,0x27,
									0x32,0x2c,0x20,0x2f,0x2b,0x30,0x26,0x37,
									0x21,0x34,0x2d,0x29,0x31,0x23,0x1c,0x1f
						};

/*
Number of rotate-left's during each round of key generation. Starting from round 1.
*/
const BYTE round_shift[16]={0x01,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x01,0x02,0x02,0x02,0x02,0x02,0x02,0x01};

/*
Array containing all the S-boxes. Starting from S1.
*/
const BYTE s_boxes[32][16]={	{0x0E,0x04,0x0D,0x01,0x02,0x0F,0x0B,0x08,0x03,0x0A,0x06,0x0C,0x05,0x09,0x00,0x07},
								{0x00,0x0F,0x07,0x04,0x0E,0x02,0x0D,0x01,0x0A,0x06,0x0C,0x0B,0x09,0x05,0x03,0x08},
								{0x04,0x01,0x0E,0x08,0x0D,0x06,0x02,0x0B,0x0F,0x0C,0x09,0x07,0x03,0x0A,0x05,0x00},
								{0x0F,0x0C,0x08,0x02,0x04,0x09,0x01,0x07,0x05,0x0B,0x03,0x0E,0x0A,0x00,0x06,0x0D},

								{0x0F,0x01,0x08,0x0E,0x06,0x0B,0x03,0x04,0x09,0x07,0x02,0x0D,0x0C,0x00,0x05,0x0A},
								{0x03,0x0D,0x04,0x07,0x0F,0x02,0x08,0x0E,0x0C,0x00,0x01,0x0A,0x06,0x09,0x0B,0x05},
								{0x00,0x0E,0x07,0x0B,0x0A,0x04,0x0D,0x01,0x05,0x08,0x0C,0x06,0x09,0x03,0x02,0x0F},
								{0x0D,0x08,0x0A,0x01,0x03,0x0F,0x04,0x02,0x0B,0x06,0x07,0x0C,0x00,0x05,0x0E,0x09},

								{0x0A,0x00,0x09,0x0E,0x06,0x03,0x0F,0x05,0x01,0x0D,0x0C,0x07,0x0B,0x04,0x02,0x08},
								{0x0D,0x07,0x00,0x09,0x03,0x04,0x06,0x0A,0x02,0x08,0x05,0x0E,0x0C,0x0B,0x0F,0x01},
								{0x0D,0x06,0x04,0x09,0x08,0x0F,0x03,0x00,0x0B,0x01,0x02,0x0C,0x05,0x0A,0x0E,0x07},
								{0x01,0x0A,0x0D,0x00,0x06,0x09,0x08,0x07,0x04,0x0F,0x0E,0x03,0x0B,0x05,0x02,0x0C},

								{0x07,0x0D,0x0E,0x03,0x00,0x06,0x09,0x0A,0x01,0x02,0x08,0x05,0x0B,0x0C,0x04,0x0F},
								{0x0D,0x08,0x0B,0x05,0x06,0x0F,0x00,0x03,0x04,0x07,0x02,0x0C,0x01,0x0A,0x0E,0x09},
								{0x0A,0x06,0x09,0x00,0x0C,0x0B,0x07,0x0D,0x0F,0x01,0x03,0x0E,0x05,0x02,0x08,0x04},
								{0x03,0x0F,0x00,0x06,0x0A,0x01,0x0D,0x08,0x09,0x04,0x05,0x0B,0x0C,0x07,0x02,0x0E},

								{0x02,0x0C,0x04,0x01,0x07,0x0A,0x0B,0x06,0x08,0x05,0x03,0x0F,0x0D,0x00,0x0E,0x09},
								{0x0E,0x0B,0x02,0x0C,0x04,0x07,0x0D,0x01,0x05,0x00,0x0F,0x0A,0x03,0x09,0x08,0x06},
								{0x04,0x02,0x01,0x0B,0x0A,0x0D,0x07,0x08,0x0F,0x09,0x0C,0x05,0x06,0x03,0x00,0x0E},
								{0x0B,0x08,0x0C,0x07,0x01,0x0E,0x02,0x0D,0x06,0x0F,0x00,0x09,0x0A,0x04,0x05,0x03},

								{0x0C,0x01,0x0A,0x0F,0x09,0x02,0x06,0x08,0x00,0x0D,0x03,0x04,0x0E,0x07,0x05,0x0B},
								{0x0A,0x0F,0x04,0x02,0x07,0x0C,0x09,0x05,0x06,0x01,0x0D,0x0E,0x00,0x0B,0x03,0x08},
								{0x09,0x0E,0x0F,0x05,0x02,0x08,0x0C,0x03,0x07,0x00,0x04,0x0A,0x01,0x0D,0x0B,0x06},
								{0x04,0x03,0x02,0x0C,0x09,0x05,0x0F,0x0A,0x0B,0x0E,0x01,0x07,0x06,0x00,0x08,0x0D},

								{0x04,0x0B,0x02,0x0E,0x0F,0x00,0x08,0x0D,0x03,0x0C,0x09,0x07,0x05,0x0A,0x06,0x01},
								{0x0D,0x00,0x0B,0x07,0x04,0x09,0x01,0x0A,0x0E,0x03,0x05,0x0C,0x02,0x0F,0x08,0x06},
								{0x01,0x04,0x0B,0x0D,0x0C,0x03,0x07,0x0E,0x0A,0x0F,0x06,0x08,0x00,0x05,0x09,0x02},
								{0x06,0x0B,0x0D,0x08,0x01,0x04,0x0A,0x07,0x09,0x05,0x00,0x0F,0x0E,0x02,0x03,0x0C},

								{0x0D,0x02,0x08,0x04,0x06,0x0F,0x0B,0x01,0x0A,0x09,0x03,0x0E,0x05,0x00,0x0C,0x07},
								{0x01,0x0F,0x0D,0x08,0x0A,0x03,0x07,0x04,0x0C,0x05,0x06,0x0B,0x00,0x0E,0x09,0x02},
								{0x07,0x0B,0x04,0x01,0x09,0x0C,0x0E,0x02,0x00,0x06,0x0A,0x0D,0x0F,0x03,0x05,0x08},
								{0x02,0x01,0x0E,0x07,0x04,0x0A,0x08,0x0D,0x0F,0x0C,0x09,0x00,0x03,0x05,0x06,0x0B}
						};

/*
Global array to store round-keys during generation for further use.
*/
QWORD round_keys[16]={0};

/*
Function to set (turn 1) nth least significant bit in a Double Word.
*/
static inline void set_bit(DWORD *in,BYTE n)
{
	*in |= (1ULL << n);
}

/*
Function to set (turn 1) nth least significant bit in a Quad Word.
*/
static inline void set_bit64(QWORD *in,BYTE n)
{
	*in |= (1ULL << n);
}

/*
Function to clear (turn 0) nth least significant bit in a Quad Word.
*/
static inline void clear_bit(QWORD *in,BYTE n)
{
	*in &= ~(1ULL <<n);
}

/*
Function to get nth least significant bit in a Double Word.
*/
static inline BYTE get_bit(const DWORD* in,BYTE  n)
{
	BYTE result=0;
	result= ( *in & (1ULL<<n) ) >> n;
	return result;
}

/*
Function to get nth least significant bit in a Quad Word.
*/
static inline BYTE get_bit64(const QWORD* in,BYTE  n)
{
	BYTE result=0;
	result= ( *in & (1ULL<<n) ) >> n;
	return result;
}

/*
A generalised rotate-left function written. It takes a Quad word input, size in bits to rotate-left,
starting (least-significant) position of bit. and pos is number of positions to rotate-left through.
e.g. During key generation, we need to rotate-left 28 to 55 bits and 0 to 27 bits separately.
*/
static void rotate(QWORD *input,const BYTE size,const BYTE start,const BYTE pos)
{
	SBYTE i,j;
	BYTE msbit;
	//this loop manages the number bits to rotate-left through.
	for(j=0;j<pos;j++)
	{
		/* stores most significant bit of part to be rotated to store it back to least significant position
		after left-shifting remaining bits */
		msbit=(*input & (1ULL<<(size-1+start)))>>(size-1+start);
		i=size-2;
		// starting from the second-most significant bit,it clears bit to its left and copies current bit to its left position.
		for(i;i>=0;i--)
		{
			clear_bit(input,start+i+1);
			if(get_bit64(input,start+i))
			{
				set_bit64(input,start+i+1) ;
			}
		}
		/* all bits except most significant bit are shifted to left. Now if most significant bit stored earlier was one, then set it to
		least significant position. Else clear the least significant bit */
		if(msbit)
		{
			set_bit64(input,start);
		}
		else
		{
			clear_bit(input,start);
		}
	}
}

/*
gen_keys generates round_keys. It takes 64-bit raw_key as input and does parity-drop,
rotate-lefts, and key-compressions to generate round keys.
*/
void gen_keys(const QWORD *raw_key)
{
	QWORD seed=0;
	SBYTE i=0,j=0;
	//transform raw key given into 56 bit seed required to generate keys, using the parity_drop table.
	for(i;i<56;i++)
	{
		if(get_bit64(raw_key,63-parity_drop[55-i])) {
			set_bit64(&seed,i);
		}
	}
	//this loop runs 16 times, generating round-key for ith round in ith iteration.
	for(i=0;i<16;i++)
	{
		//rotate-left the least significant 28 bits of seed.
		rotate(&seed,28,0,round_shift[i]);
		//rotate-left the most significant 28 bits of seed.
		rotate(&seed,28,28,round_shift[i]);
		/* The above two rotates need to be done separately as result of rotating 56 bit seed as a whole will have
		different effect than this which is not desired. */

		/* now the key_compression table is applied on rotated seed to generate 48 bit round key.
		each jth bit of ith round key is set in following loop. */
		for(j=47;j>=0;j--)
		{
			if(get_bit64(&seed,55-key_compression[47-j]))
			{
				set_bit64(&round_keys[i],j);
			}
		}
	}
}

/*
This function acts as expansion D-box used in DES-function. It takes 32-bit input and outputs a 48-bit word.
As there is no facility to store 48-bit word explicitly, it is stored in a 64-bit Quad-word.
*/
QWORD exp_d(const DWORD *in)
{
	QWORD ret=0;
	BYTE j=0,i=0;

	/* Following loop is used to emulate expansion D-box in DES function.
	The mapping of ith least significant bit of output to least significant bit of input is given by
	f(i,j) = ((i-(2*j)-1)>=0 ? (i-(2*j)-1)%32 : ((31-i+(2*j))%32)).
	Hence, for each i, we can check if f(i,j) is 1 or 0. If it is 1, we set the ith bit of output as 1.
	 */
	for(i;i<48;i++)
	{
		j=i/6;
		if(get_bit(in,((i-(2*j)-1)>=0 ? (i-(2*j)-1)%32 : ((31-i+(2*j))%32))))
		{
			set_bit64(&ret,i);
		}
	}
	return ret;
}

/*
This function emulates nth round (n is 0 based, meaning it will take values from 0-15) of DES.
It takes Quadword reference of 64 bits as input and transforms it into output of that round.
*/
void des_round(QWORD *input,BYTE n)
{
	//This uses the exp_d function to expand the 32 least significant bits into 48 bits.
	QWORD expansion=exp_d(((DWORD*)input));
	DWORD s_out=0,d_out=0;
	SBYTE i=7,j,temp;
	BYTE row,col;
	//This XORs the expansion obtained from D-box with round key of that particular round.
	expansion ^= round_keys[n];

	/* This loop iterates one time for one s-box. We need to get 32 bit output from 48-bit XORd word above.
	Each iteration generates 4 bits of output from one s-box., effectively generating the required 32 bits in total 8 iterations. */
	for(i;i>=0;i--)
	{
		row=col=0;
		//get the two bit row number of s-box from first and sixth bit of 6 bit chunk.
		row|=(get_bit64(&expansion,6*i+5)<<1);
		row|=get_bit64(&expansion,6*i);
		//get the 4 bit column number of s-box from 2-4th bits of 6 bit chunk.
		for(j=0;j<4;j++)
		{
			col|=get_bit64(&expansion,6*i+j+1)<<j;
		}
		//extract the 4 bits stored in that s-box at row-column position determined above and store it in appropriate positions in s_out.
		s_out|= ( (s_boxes[(7-i)*4+row][col]) | 0ULL) << (i*4);
	}

	//now permute the bits in s_out according to the straight D-box in DES function, and store it in d_out.
	for(i=31;i>=0;i--)
	{
		if(get_bit(&s_out,31-straight_d[31-i]))
		{
			set_bit(&d_out,i);
		}
	}

	/* XOR the d_out so obtained with most significant 32 bits of input. As d_out is Double word and we need to XOR it with positions
	in a Quad word, it is first ORd with a 64 bit 0, and then the 64 bit number is shifted by 32 bits and XORd. */
	*input ^= (d_out | 0ULL) << 32;

	/* finally swap the left and right halves (32-bits each). The generalised rotate function is used here to rotate whole 64 bit Quad word
	by 32 bits, effectively swapping the left and right halves. This is not done in the last round. */
	if(n<15)
	{
		rotate(input,64,0,32);
	}
}

/*
This function encrypts a block of 64 bits with DES, using initial permutation, 16 rounds using des_round function,
and final permutation. It transforms Quad word input into ciphertext in the end.
*/
void des_encrypt_block(QWORD *input)
{
	SBYTE i=63;
	QWORD round_seed=0;

	// Perform initial permutation on input plaintext.
	for(i;i>=0;i--)
	{
		if(get_bit64(input,63-init_perm[63-i]))
		{
			set_bit64(&round_seed,i);
		}
	}

	// Apply 16 rounds of DES on permuted plaintext.
	for(i=0;i<16;i++)
	{
		des_round(&round_seed,i);
	}

	*input=0;
	// Apply final permutation on Quad word obtained after 16 rounds and store it into input.
	for(i=63;i>=0;i--)
	{
		if(get_bit64(&round_seed,63-final_perm[63-i]))
		{
			set_bit64(input,i);
		}
	}
}

int main()
{
	QWORD seed_key=0xaabb09182736ccdd;
	gen_keys(&seed_key);
	QWORD *temp=malloc(sizeof(QWORD));
	*temp=0x123456abcd132536; 
	des_encrypt_block(temp);
	printf("ciphertext : %llx\n",*temp);
}